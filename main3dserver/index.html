<!DOCTYPE html>
<html>

<body>
    <!-- Three.js本体とGLTFローダー -->
    <script type="importmap">
    {
      "imports": {
        "three" : "./js/three.module.js",
        "three/loaders/": "./jsm/loaders/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/loaders/GLTFLoader.js';
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        // シーンを追加 
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        // ライトを追加 
        // 環境光 
        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
        scene.add(ambientLight);
        // 太陽光 
        const light = new THREE.DirectionalLight(0xFFFFFF, 1);
        scene.add(light);
        // ポイントライト 
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        scene.add(pointLight);

        // 1km四方の地面を追加 
        const geometry = new THREE.PlaneGeometry(10000, 10000);
        const material = new THREE.MeshBasicMaterial(
            { color: 0x666666, side: THREE.DoubleSide });
        const plane = new THREE.Mesh(geometry, material);
        plane.rotation.x = 90 * Math.PI / 180;
        scene.add(plane);

        // カメラの追加 
        const camera = new THREE.PerspectiveCamera(
            45, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.z = 500;

        // レンダラーを追加 
        const renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 描画開始 
        animate();
        //javascriptでGPSを取得
        // 現在位置を取得する
        function successFunc(position) {
                // 緯度をアラート表示
                alert(position.coords.latitude);

                // 経度をアラート表示
                alert(position.coords.longitude);
                //変数に格納
                // 取得したデータの整理
                var data = position.coords;
                // データの整理
                var lat = data.latitude;
                var lng = data.longitude;
                var alt = data.altitude;
                var accLatlng = data.accuracy;
                var accAlt = data.altitudeAccuracy;
                var heading = data.heading;			//0=北,90=東,180=南,270=西
                var speed = data.speed;
        }
        // 失敗した時の関数
        function errorFunc(error) {
            // エラーコードのメッセージを定義
            var errorMessage = {
                0: "原因不明のエラーが発生しました…。",
                1: "位置情報の取得が許可されませんでした…。",
                2: "電波状況などで位置情報が取得できませんでした…。",
                3: "位置情報の取得に時間がかかり過ぎてタイムアウトしました…。",
            };
                // エラーコードに合わせたエラー内容をアラート表示
                alert(errorMessage[error.code]);
        }
        // オプション・オブジェクト
        var optionObj = {
            "enableHighAccuracy": false,
            "timeout": 8000,
            "maximumAge": 5000,
        };
        navigator.geolocation.getCurrentPosition(successFunc, errorFunc, optionObj);
        //位置情報を直交座標系へ変換
        function calc_xy(phi_deg, lambda_deg, phi0_deg, lambda0_deg) {
                // 緯度経度を平面直角座標に変換する
                // - input:
                //     (phi_deg, lambda_deg): 変換したい緯度・経度[度]（分・秒でなく小数であることに注意）
                //     (phi0_deg, lambda0_deg): 平面直角座標系原点の緯度・経度[度]（分・秒でなく小数であることに注意）
                // - output:
                //     x: 変換後の平面直角座標[m]
                //     y: 変換後の平面直角座標[m]
                //
                // 緯度経度・平面直角座標系原点をラジアンに直す
                const phi_rad = phi_deg * Math.PI / 180;
                const lambda_rad = lambda_deg * Math.PI / 180;
                const phi0_rad = phi0_deg * Math.PI / 180;
                const lambda0_rad = lambda0_deg * Math.PI / 180;

                // 補助関数
                function A_array(n) {
                    const A0 = 1 + (n ** 2) / 4. + (n ** 4) / 64.;
                }
        }
        //適宜引数に与える数を定義すること
        var random = Math.floor(Math.random() * 11);
        // GLTFファイルを読み込む 
        if (false){
            const GLTFFILE = 'gltf/test2.glb';
            const gltfLoader = new GLTFLoader()
            gltfLoader.load(GLTFFILE, (gltf) => {
                scene.add(gltf.scene);
            }, undefined, (error) => {
                console.error(error);
            });

        }else if(true){
            const GLTFFILE ='gltf/saisyuu5-6.glb';
            const gltfLoader = new GLTFLoader()
            gltfLoader.load(GLTFFILE, (gltf) => {
                scene.add(gltf.scene);
            }, undefined, (error) => {
                console.error(error);
            });
        }else if(false){
            const GLTFFILE ='gltf/test.glb';
            const gltfLoader = new GLTFLoader()
            gltfLoader.load(GLTFFILE, (gltf) => {
                scene.add(gltf.scene);
            }, undefined, (error) => {
                console.error(error);
            });
        }
        // マウスイベントなどを設定 
        document.addEventListener('mousemove', onDocumentMouseMove);
        window.addEventListener('resize', onWindowResize);

        // 描画処理 
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            camera.position.x += (mouseX - camera.position.x) * .05;
            camera.position.y += (-mouseY - camera.position.y) * .05;
            //camera.lookAt(new THREE.Vector3(0, 10, 0));
            renderer.render(scene, camera); 
        }

        // リサイズ時のカメラ調整 
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // マウスが動いたときの座標記録 
        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - windowHalfX) / 2;
            mouseY = (event.clientY - windowHalfY) / 2;
        } 
    </script>
</body>

</html>